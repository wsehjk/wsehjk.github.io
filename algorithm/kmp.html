<h1>kmp笔记</h1>
<p><code>kmp</code>算法是巧妙的字符串匹配算法。当模式串(<code>pattern</code>)和文本(<code>text</code>)不匹配时，利用模式串的性质得到下一个应该比较的模式串字符，文本串指针不回退，达到线性的运行效率。</p>
<h2>brute force 解法</h2>
<p>text:    <code>baccbacbabcbabbabcbab</code></p>
<p>pattern: <code>baccbab</code></p>
<p>暴力解法中，比较第6个字符发现不匹配(<code>c</code> 和 <code>b</code>)，文本指针回到1，模式串指针回到0，重新开始匹配。代码实现为：</p>
<pre><code class="language-c++">int search(const std::string&amp; text, const std::string&amp; pat) {
    for(int i = 0; i &lt;= text.size() - pat.size(); ++i) {
        for(j = 0; j &lt; pat.size(); ++j) {
            if (text[i+j] != pat[j]) {
                break;
            }
        }
        if (j == pat.size()) {
            return i;
        }
    }
    return -1;
}
</code></pre>
<p>发现不匹配时，文本串指针都需要退回(back up)，效率低。</p>
<h2>kmp nondeterministic finite state machine(nfa)解法</h2>
<p>kmp算法利用已有的匹配信息避免文本串指针回溯。即当<code>text[i]</code>和<code>pattern[j]</code>不匹配时，有<code>text[i-j+1:i]</code>和<code>pattern[0:j-1]</code>匹配，在上面的例子中，<code>i = 6, j = 6</code>， <code>text[i] != pattern[j]</code>，已匹配的前缀就是<code>baccba</code>。观察到已经匹配的字符串中，有前缀<code>ba</code>和后缀<code>ba</code>匹配，模式串指针回退到2继续匹配。</p>
<p>现在的问题是，对于模式串<code>pattern</code>能否提前计算出<code>next</code>数组，<code>k = next[i], k != i+1</code>表示在<code>pattern[0:i]</code>中有<strong>最长</strong>的前缀和后缀<code>pattern[0:k-1] = pattern[i-k+1:i]</code>。首先有<code>next[0] = 0</code>。计算<code>next[i]</code>可以利用<code>k = next[i-1]</code>，即有<code>pattern[0:k-1] = pattern[i-k:i-1]</code>。如果<code>pattern[k] = pattern[i]</code>，那么<code>next[i] = k+1</code>。如果<code>pattern[k] != pattern[i]</code>呢？
这时候要查看<code>pattern[i-k:i-1]</code>的后缀和<code>pattern[0:k-1]</code>的前缀匹配的长度，因为有<code>pattern[0:k-1] = pattern[i-k:i-1]</code>，所以要查看<code>pattern[0:k-1]</code>的后缀和<code>pattern[0:k-1]</code>的前缀匹配的长度，这个信息就是<code>t = next[k-1]</code>， 如果<code>pattern[t] = pattern[i]</code>，那么<code>next[i] = t+1</code>。如果<code>pattern[t] != pattern[i]</code>呢？所以这是个迭代<code>k</code>的过程。</p>
<pre><code class="language-latex">next[0] = 0
对于i &gt; 0, k = next[i-1], 如果pattern[k] != pattern[i] k &lt;- next[k-1]
否则 next[i] = k+1
</code></pre>
<p>代码实现为</p>
<pre><code class="language-c++">class KMP {
   private:
    std::string pat_;
    std::vector&lt;int&gt; next_;
    void GetNext() {
        int n = pat_.size();
        for (int i = 1; i &lt; n; ++i) {
            int k = next_[i - 1];
            while (k != 0 &amp;&amp; pat_[k] != pat_[i]) {
                k = next_[k - 1];
            }
            //判断 k!= 0 避免 pat_[0] != pat_[i]，计算next_[-1]
            if (pat_[k] == pat_[i]) {
                k ++;
            }
            next_[i] = k;
        }
    }
   public:
    KMP(const std::string&amp; pat) : pat_(pat), next_(pat.size(), 0) {      
        GetNext(); 
    }
    // 给定文本串，返回模式串在文本串中出现的位置
    std::vector&lt;int&gt; Search(const std::string&amp; txt) {
        std::vector&lt;int&gt; pos;
        int m = txt.size();
        int c = 0;  //对于i, c
                    //表示已经匹配的字符数，或者和txt[i]比较的模式串字符下标
        for (int i = 0; i &lt; m; ++i) {
            while (c &amp;&amp; pat_[c] != txt[i]) {
                c = next_[c - 1];
            }
            if (pat_[c] == txt[i]) {
                c ++;
            }
            if (c == pat_.size()) {
                pos.push_back(i - c + 1);
            }
        }
        return pos;
    }
};
</code></pre>
